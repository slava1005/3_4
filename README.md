## Домашнее задание к занятию «Обновление приложений»
### Задание 1. Выбрать стратегию обновления приложения и описать ваш выбор
1. Имеется приложение, состоящее из нескольких реплик, которое требуется обновить.
2. Ресурсы, выделенные для приложения, ограничены, и нет возможности их увеличить.
3. Запас по ресурсам в менее загруженный момент времени составляет 20%.
4. Обновление мажорное, новые версии приложения не умеют работать со старыми.
5. Вам нужно объяснить свой выбор стратегии обновления приложения.
Задание 2. Обновить приложение
1. Создать deployment приложения с контейнерами nginx и multitool. Версию nginx взять 1.19. Количество реплик — 5.
2. Обновить версию nginx в приложении до версии 1.20, сократив время обновления до минимума. Приложение должно быть доступно.
3. Попытаться обновить nginx до версии 1.28, приложение должно оставаться доступным.
4. Откатиться после неудачного обновления.
### Дополнительные задания — со звёздочкой*
Задания дополнительные, необязательные к выполнению, они не повлияют на получение зачёта по домашнему заданию. 
Но мы настоятельно рекомендуем вам выполнять все задания со звёздочкой. Это поможет лучше разобраться в материале.

Задание 3*. Создать Canary deployment
1. Создать два deployment'а приложения nginx.
2. При помощи разных ConfigMap сделать две версии приложения — веб-страницы.
3. С помощью ingress создать канареечный деплоймент, чтобы можно было часть трафика перебросить на разные версии приложения.
4. 
### Выполнение задания 1. Выбрать стратегию обновления приложения и описать ваш выбор
Думаю, что для описанных условий больше подходит стратегия Rolling Update. Это стратегия обновления по умолчанию и она не требовательна к ресурсам. 
Поскольку есть ограничения по ресурсам, то необходимо использовать следующие параметры:

maxSurge: 20%
maxUnavailable: 20%
maxSurge: 20% даст возможность дополнительно запустить 20% реплик с новой версией приложения сверх имеющегося количества. 
Например, если у меня 5 реплик приложения, то maxSurge: 20% даст возможность запустить еще одну реплику приложения с новой версией.

maxUnavailable: 20% даст возможность выключить 20% реплик со старой версией приложения во время обновления. Например, если у меня 5 реплик приложения, 
то во время обновления будет выключена одна реплика чтобы дать ресурсы реплике с новым приложением.

Но если учитывать то, что обновления мажорное и новые версии приложения не умеют работать со старыми, то можно поставить параметр maxUnavailable: 100%. 
Это позволит не удалять старые реплики до проверки новых. Старые реплики будут занимать ресурсы, но если обращений к этим репликам не будет, то значительного потребления ресурсов они не вызовут. 
После проверки новых реплик можно будет удалить старые.

Также стоит помнить, что обновления лучше проводить в то время, когда зафиксирован наибольший период простоя кластера Kubernetes.

Но если ресурсов нет совсем, то можно применить стратегию обновления Recreate. Это приведет к остановке старых подов, соответственно прекращению любых запросов к нему. 
После остановки старых подов создадутся новые поды и полностью удалятся старые поды.

### Выполнение задания 2. Обновить приложение
Пишу манифест deployment приложения с контейнерами nginx и multitool. Версию nginx для начала использую 1.19. Количество реплик — 5.
Ссылка на манифест deployment: https://github.com/slava1005/3_4/blob/main/manifest/deployment_1.19.yaml

Применяю манифест, получаю 5 реплик приложения, где используется nginx версии 1.19:

![img1_1](https://github.com/user-attachments/assets/4f7c25fa-21a6-4739-9b0d-f22f43dc68e4)

![img1_2](https://github.com/user-attachments/assets/366af506-1da6-48a1-8dd5-7c9e445a5cbf)

Обновляем версию nginx в манифесте deployment до 1.20, также меняем аннотацию для дальнейшего понимания происходящих изменений. Стратегию обновления выберем RollingUpdate, 
в параметр maxSurge ставим значение 2, в параметр maxUnavailable ставим значение 3. Это даст возможность оставить работающими 2 реплики приложения со старой версией даже 
при проблемах с обновлением, что выполнит условие доступности приложения. Три реплики приложения начнут выключаться и вместо них будут создаваться три реплики с новой 
версией nginx. После запуска трех реплик с новой версией приложения, две старые реплики будут уничтожены и вместо них запустятся две реплики с новой версией приложения.
Применяю манифест с обновлением версии nginx:

![img1_3](https://github.com/user-attachments/assets/18655996-5e6c-4a91-9905-abda88dbbd70)

Постепенно запустилось 5 подов с новой версией nginx. В процессе обновления сначала 2 старых пода продолжали работать, 3 пода выключились и 3 пода создались, 
после чего 2 старых пода выключились и вместо них запустились 2 новых пода. Версия nginx обновилась до 1.20:

![img1_4](https://github.com/user-attachments/assets/9c395ca0-3524-4434-9cf7-0d9d45ad15f6)

Историю обновлений можно посмотреть командой kubectl -n app rollout history deployment:

![img1_5](https://github.com/user-attachments/assets/76a2bb24-9e0e-4b67-be05-8a52a600e4db)

В настоящее время мы находимся на второй ревизии приложения.

Ссылка на манифест deployment: - https://github.com/slava1005/3_4/blob/main/manifest/deployment_1.20.yaml

Пробуем обновить версию nginx до 1.28:

![img1_6](https://github.com/user-attachments/assets/30bb7436-2bdc-47d6-8ed5-3c96c2954766)

Мы видим, что две старые реплики продолжают работать, но три новые не могут запуститься из-за отсутствия образа nginx 1.28. За счет двух старых реплик доступность приложения сохраняется.

Ссылка на манифест deployment: - https://github.com/slava1005/3_4/blob/main/manifest/deployment_1.28.yaml

Откачусь к прошлой версии приложения после неудачного обновления:

![img1_7](https://github.com/user-attachments/assets/caeaaa65-0b24-43a7-95db-1766a91f973a)

Те поды, что не смогли запуститься при прошлом обновлении были уничтожены, а вместо них запустились три пода с прошлой версией обновления.

Финальная история обновлений выглядит следующим образом:

![img1_8](https://github.com/user-attachments/assets/c999b4ee-fe9f-4c44-8dbc-844e50d56879)

Поскольку на второй ревизии мы обновили версию nginx до 1.20, но дальше мы на эту же версию откатились, то в истории была удалена вторя ревизия и текущая ревизия запущенного проложения стала четвертой.
